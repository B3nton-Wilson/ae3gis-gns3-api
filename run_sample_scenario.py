#!/usr/bin/env python3
import requests
from dataclasses import dataclass
from typing import Dict, List, Tuple

from core.template_cache import TemplateCacheError, load_registry
from models import APISettings

# ========= Edit these lines =========
API_BASE = "http://127.0.0.1:8000"
BUILD_URL = f"{API_BASE}/scenario/build"
SCRIPTS_URL = f"{API_BASE}/scripts/push"

PROJECT_NAME = "ae3gis-root-2"
# ========= ================== =========


# How many scenarios (tiles) to create and how they are laid out
NUM_SCENARIOS = 9
SCENARIOS_PER_ROW = 3             # how many tiles per row
TILE_WIDTH = 900                  # px between scenarios horizontally
TILE_HEIGHT = 500                 # px between scenarios vertically
CANVAS_TOP_LEFT = (-500, -400)  # where the first scenario starts

# Clients layout inside each scenario (tile)
CLIENTS_PER_SCENARIO = 13
CLIENTS_PER_ROW = 13
NODE_SPACING_X = 50
NODE_SPACING_Y = 50

# Special node offsets inside a tile (relative to tile origin)
SWITCH_OFFSET = (300, -140)
DHCP_OFFSET = (600, -140)
SERVER_OFFSET = (300, -250)

# Scripts (local to your machine)
SERVER_SCRIPT = "./run_server.sh"
DHCP_SCRIPT = "./run_dhcp.sh"
CLIENT_SCRIPT = "./run_http.sh"
SCRIPTS_CONCURRENCY = 13  # the API may still run uploads concurrently; our calls remain sequential

ID_PAD = 2  # zero pad for names like 01, 02, ...
START_AT = 1
# ===========================================

# Template IDs (resolved from cache generated by the FastAPI service)
_settings = APISettings()  # type: ignore[call-arg]

try:
    _registry = load_registry(_settings.templates_cache_path)
except TemplateCacheError as exc:
    raise SystemExit(
        f"{exc}\nStart the FastAPI service once so it can populate the template cache."
    ) from exc

_template_raw = _registry.get("templates")
if not isinstance(_template_raw, dict):
    raise SystemExit(
        "Template cache is missing the 'templates' mapping. "
        "Start the FastAPI service to refresh the cache."
    )

_template_source: Dict[str, str] = {
    str(name): str(identifier)
    for name, identifier in _template_raw.items()
    if isinstance(name, str) and isinstance(identifier, str)
}

_project_source = _registry.get("projects") or {}
_projects_cache = {
    str(name): str(identifier)
    for name, identifier in getattr(_project_source, "items", lambda: [])()
    if isinstance(name, str) and isinstance(identifier, str)
}

if PROJECT_NAME not in _projects_cache:
    available_projects = ", ".join(sorted(_projects_cache)) or "<none>"
    raise SystemExit(
        "Project not found in cache: "
        + PROJECT_NAME
        + f". Available projects: {available_projects}."
        + "\nStart the FastAPI service to refresh the cache or update PROJECT_NAME."
    )

PROJECT_ID = _projects_cache[PROJECT_NAME]

_server_info = _registry.get("server") or {}
GNS3_BASE_URL = str(_server_info.get("base_url") or _settings.gns3_base_url).rstrip("/")
GNS3_SERVER_IP = str(_server_info.get("ip") or _settings.gns3_server_ip)

if not GNS3_BASE_URL:
    raise SystemExit(
        "Unable to determine GNS3 base URL from cache or settings. "
        "Set GNS3_BASE_URL in the environment or refresh the cache."
    )

REQUIRED_TEMPLATE_NAMES: Tuple[str, ...] = (
    "test-client:v0.2",
    "nginx-server:v0.2",
    "open-v-switch:v0.3",
    "isc-dhcp-server:v0.5",
)


def _resolve_templates(required: Tuple[str, ...]) -> Dict[str, str]:
    missing = [name for name in required if name not in _template_source]
    if missing:
        available = ", ".join(sorted(_template_source)) or "<none>"
        raise SystemExit(
            "Missing templates in cache: "
            + ", ".join(missing)
            + f". Available templates: {available}."
            + "\nStart the FastAPI service to refresh the cache."
        )
    return {name: _template_source[name] for name in required}


TEMPLATES: Dict[str, str] = _resolve_templates(REQUIRED_TEMPLATE_NAMES)


@dataclass
class Tile:
    col: int
    row: int
    x: int
    y: int


def tile_for_index(idx: int) -> Tile:
    col = idx % SCENARIOS_PER_ROW
    row = idx // SCENARIOS_PER_ROW
    x = CANVAS_TOP_LEFT[0] + col * TILE_WIDTH
    y = CANVAS_TOP_LEFT[1] + row * TILE_HEIGHT
    return Tile(col, row, x, y)


def make_clients(tile: Tile, start_id: int) -> Tuple[List[Dict], List[str], int]:
    nodes = []
    names = []
    next_id = start_id
    for i in range(CLIENTS_PER_SCENARIO):
        r = i // CLIENTS_PER_ROW
        c = i % CLIENTS_PER_ROW
        x = tile.x + c * NODE_SPACING_X
        y = tile.y + r * NODE_SPACING_Y
        name = f"Client-{next_id:0{ID_PAD}d}"
        nodes.append({
            "name": name,
            "template_id": TEMPLATES["test-client:v0.2"],
            "x": x,
            "y": y
        })
        names.append(name)
        next_id += 1
    return nodes, names, next_id


def make_special_nodes(tile: Tile, scenario_idx: int) -> Tuple[List[Dict], Dict[str, str]]:
    sid = scenario_idx + START_AT
    sw_name = f"OpenvSwitch-{sid:0{ID_PAD}d}"
    dhcp_name = f"DHCP-{sid:0{ID_PAD}d}"
    server_name = f"Server-{sid:0{ID_PAD}d}"
    sx, sy = SWITCH_OFFSET
    dx, dy = DHCP_OFFSET
    vx, vy = SERVER_OFFSET

    nodes = [
        {"name": sw_name, "template_id": TEMPLATES["open-v-switch:v0.3"], "x": tile.x + sx, "y": tile.y + sy},
        {"name": dhcp_name, "template_id": TEMPLATES["isc-dhcp-server:v0.5"], "x": tile.x + dx, "y": tile.y + dy},
        {"name": server_name, "template_id": TEMPLATES["nginx-server:v0.2"], "x": tile.x + vx, "y": tile.y + vy},
    ]
    return nodes, {"switch": sw_name, "dhcp": dhcp_name, "server": server_name}


def make_links(client_names: List[str], switch_name: str, dhcp_name: str, server_name: str) -> List[Dict]:
    links = []
    # clients to switch (client adapter 0 -> switch adapters 1..n)
    for i, cname in enumerate(client_names, start=1):
        links.append({
            "nodes": [
                {"node_id": cname, "adapter_number": 0, "port_number": 0},
                {"node_id": switch_name, "adapter_number": i, "port_number": 0},
            ]
        })
    # server to switch (next adapter)
    next_adapter = len(client_names) + 1
    links.append({
        "nodes": [
            {"node_id": server_name, "adapter_number": 0, "port_number": 0},
            {"node_id": switch_name, "adapter_number": next_adapter, "port_number": 0},
        ]
    })
    # dhcp to switch (next adapter)
    links.append({
        "nodes": [
            {"node_id": dhcp_name, "adapter_number": 0, "port_number": 0},
            {"node_id": switch_name, "adapter_number": next_adapter + 1, "port_number": 0},
        ]
    })
    return links


def build_payload(tile: Tile, scenario_idx: int, next_client_id: int) -> Tuple[Dict, List[str], Dict[str, str], int]:
    client_nodes, client_names, after_id = make_clients(tile, next_client_id)
    special_nodes, special_names = make_special_nodes(tile, scenario_idx)
    links = make_links(client_names, special_names["switch"], special_names["dhcp"], special_names["server"])

    payload = {
        "base_url": GNS3_BASE_URL,
        "start_nodes": True,
        "username": "gns3",
        "password": "gns3",
        "scenario": {
            "gns3_server_ip": GNS3_SERVER_IP,
            "project_name": PROJECT_NAME,
            "project_id": PROJECT_ID,
            "templates": TEMPLATES,  # do not repeat IDs elsewhere
            "nodes": client_nodes + special_nodes,
            "links": links,
        }
    }
    return payload, client_names, special_names, after_id


def post_json(url: str, data: Dict) -> Dict:
    r = requests.post(url, json=data, timeout=360)
    r.raise_for_status()
    return r.json() if r.headers.get("content-type", "").startswith("application/json") else {"text": r.text}


def push_script(node_name: str, local_path: str, remote_path: str, shell: str = "sh", timeout: int = 10) -> None:
    payload = {
        "scripts": [{
            "node_name": node_name,
            "local_path": local_path,
            "remote_path": remote_path,
            "run_after_upload": True,
            "executable": True,
            "overwrite": True,
            "run_timeout": timeout,
            "shell": shell
        }],
        "gns3_server_ip": GNS3_BASE_URL,
        "concurrency": SCRIPTS_CONCURRENCY,
        "username": "gns3",
        "password": "gns3",
    }
    post_json(SCRIPTS_URL, payload)


def push_batch_scripts(node_names: List[str], local_path: str, remote_path: str, shell: str = "sh", timeout: int = 10) -> None:
    scripts = [{
        "node_name": n,
        "local_path": local_path,
        "remote_path": remote_path,
        "run_after_upload": True,
        "executable": True,
        "overwrite": True,
        "run_timeout": timeout,
        "shell": shell
    } for n in node_names]
    payload = {
        "scripts": scripts,
        "gns3_server_ip": GNS3_BASE_URL,
        "concurrency": SCRIPTS_CONCURRENCY,
        "username": "gns3",
        "password": "gns3",
    }
    post_json(SCRIPTS_URL, payload)


def main():
    next_client_id = START_AT

    with requests.Session() as _:
        for scenario_idx in range(NUM_SCENARIOS):
            tile = tile_for_index(scenario_idx)
            build_body, client_names, special_names, next_client_id = build_payload(tile, scenario_idx, next_client_id)

            print(f"Building scenario {scenario_idx + 1}/{NUM_SCENARIOS} at tile ({tile.col},{tile.row}) origin=({tile.x},{tile.y})")
            post_json(BUILD_URL, build_body)

            # Sequential script pushes (order matters)
            print("  Pushing server script...")
            push_script(special_names["server"], SERVER_SCRIPT, "/usr/local/bin/run_server.sh")
            print("  Pushing DHCP script...")
            push_script(special_names["dhcp"], DHCP_SCRIPT, "/usr/local/bin/run_dhcp.sh")
            print("  Pushing client scripts...")
            push_batch_scripts(client_names, CLIENT_SCRIPT, "/usr/local/bin/run_http2.sh")

    print("Done.")


if __name__ == "__main__":
    main()